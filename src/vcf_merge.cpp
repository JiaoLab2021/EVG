// g++ vcf_merge_depth.cpp -o vcf_merge_depth -lz

#include "../include/vcf_merge.hpp"

using namespace std;

int main_merge(int argc, char** argv)
{
    // EVG running mode
    string mode = "specific";

    string trueVcf;
    string ParagraphVcf;
    string GraphTyper2Vcf;
    string BayesTyperVcf;
    string mapVcf;
    string giraffeVcf;
    string GraphAlignerVcf;
    string PanGenieVcf;

    // Sample name
    string sampleName = "";

    // Output file name
    string outputFileName = "";

    // Input parameter
    int c;
    
    while (true)
    {
        static const struct option long_options[] = {
            {"vcf", required_argument, 0, 'v'},
            {"Paragraph", required_argument, 0, '1'},
            {"GraphTyper2", required_argument, 0, '2'},
            {"BayesTyper", required_argument, 0, '3'},
            {"VG-MAP", required_argument, 0, '4'},
            {"VG-Giraffe", required_argument, 0, '5'},
            {"GraphAligner", required_argument, 0, '6'},
            {"PanGenie", required_argument, 0, '7'},
            {"name", required_argument, 0, 'n'},

            {"mode", required_argument, 0, 'm'},
            {"out", required_argument, 0, 'o'},
            {"help", no_argument, 0, 'h'},
            {0, 0, 0, 0}
        };

        int option_index = 0;

        c = getopt_long (argc, argv, "v:1:2:3:4:5:6:7:n:m:o:h", long_options, &option_index);

        if (c == -1)
            break;
        
        switch (c)
        {
        case 'v':
            trueVcf = optarg;
            break;
        case '1':
            ParagraphVcf = optarg;
            break;
        case '2':
            GraphTyper2Vcf = optarg;
            break;
        case '3':
            BayesTyperVcf = optarg;
            break;
        case '4':
            mapVcf = optarg;
            break;
        case '5':
            giraffeVcf = optarg;
            break;
        case '6':
            GraphAlignerVcf = optarg;
            break;
        case '7':
            PanGenieVcf = optarg;
            break;
        case 'n':
            sampleName = optarg;
            break;
        case 'm':
            mode = optarg;
            break;
        case 'o':
            outputFileName = optarg;
            break;
        case 'h':
        case '?':
            help_merge(argv);
            exit(1);
            break;
        default:
            abort ();
        }
    }

    if (argc <= 2) {
        help_merge(argv);
        return 1;
    }

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Running ...\n";

    // Check parameter
    if (mode != "specific" && mode != "all")
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Mode error: specific/all." << endl;
        help_merge(argv);
        exit(1);
    }
    if (sampleName.size() == 0)
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Empty sample name: -n." << endl;
        help_merge(argv);
        exit(1);
    }


    // init 
    VCFMerge VCFMerge(
        mode, 
        trueVcf, 
        ParagraphVcf, 
        GraphTyper2Vcf, 
        BayesTyperVcf, 
        mapVcf, 
        giraffeVcf, 
        GraphAlignerVcf, 
        PanGenieVcf, 
        sampleName, 
        outputFileName
    );

    // build base index
    VCFMerge.build_basefile_index();

    // build software index
    VCFMerge.run_index_merge();

    // filter
    VCFMerge.vcf_merge_filter();

    // save
    VCFMerge.result_save();


    cerr << "[" << __func__ << "::" << getTime() << "] " << "Done ...\n";

    return 0;
}

// Help document
void help_merge(char** argv)
{
  cerr << "usage: " << argv[0] << " " << argv[1] << " -v [options]" << endl
       << "merge VCF files generated by genome graph software." << endl
       << endl
       << "required arguments (Note: vcf files must be sorted):" << endl
       << "    -v, --vcf            FILE      base vcf file for genotyping" << endl
       << "    --Paragraph          FILE      output file of Paragraph" << endl
       << "    --GraphTyper2        FILE      output file of GraphTyper2" << endl
       << "    --BayesTyper         FILE      output file of BayesTyper" << endl
       << "    --VG-MAP             FILE      output file of VG-MAP" << endl
       << "    --VG-Giraffe         FILE      output file of VG-Giraffe" << endl
       << "    --GraphAligner       FILE      output file of GraphAligner" << endl
       << "    --PanGenie           FILE      output file of PanGenie" << endl
       << "    -n, --name           STRING    used to extract genotyping result, after the FORMAT of vcf" << endl
       << endl
       << "optional arguments:" << endl
       << "    -m, --mode           STRING    software mode (specific/all) [specific]" << endl
       << "    -o, --out            FILE      output filename [stdout]" << endl
       << endl
       << "    -h, --help                     print this help document" << endl;
}


/**
 * init
 *
 * @param mode
 * @param trueVcf
 * @param ParagraphVcf
 * @param GraphTyper2Vcf
 * @param BayesTyperVcf
 * @param MAPVcf
 * @param GiraffeVcf
 * @param GraphAlignerVcf
 * @param PanGenieVcf
 * @param sampleName         Sample names to be merged
 * 
**/
VCFMerge::VCFMerge(
    const string& mode,
    const string& trueVcf, 
    const string& ParagraphVcf, 
    const string& GraphTyper2Vcf, 
    const string& BayesTyperVcf, 
    const string& MAPVcf, 
    const string& GiraffeVcf, 
    const string& GraphAlignerVcf, 
    const string& PanGenieVcf, 
    const string& sampleName, 
    const string& outputFileName
) : mode_(mode), trueVcf_(trueVcf), ParagraphVcf_(ParagraphVcf), GraphTyper2Vcf_(GraphTyper2Vcf), 
    BayesTyperVcf_(BayesTyperVcf), MAPVcf_(MAPVcf), GiraffeVcf_(GiraffeVcf), 
    GraphAlignerVcf_(GraphAlignerVcf), PanGenieVcf_(PanGenieVcf), sampleName_(sampleName), 
    outputFileName_(outputFileName)
{
    if (trueVcf_.empty())
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Please enter the -v/--vcf parameter" << endl;
        exit(1);
    }
}


/**
 * The base file index is built without filtering the vcf and is used to create the base index. The file is a real vcf file
 * 
 * 
 * @return void
**/
void VCFMerge::build_basefile_index()
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Building index: '" << trueVcf_ << "'" << endl;

    check_vcf_sort(trueVcf_);

     // input file stream
    VCFINFOSTRUCT INFOSTRUCTTMP;
    VCFOPEN VCFOPENCLASS(trueVcf_);

    while(VCFOPENCLASS.read(INFOSTRUCTTMP))
    {
        if (INFOSTRUCTTMP.line.find("#") != string::npos)  // Comment line
        {
            // #CHROM comment line index
            if (INFOSTRUCTTMP.line.find("#CHROM") != string::npos)
            {
                vector<string> informationsVecTmp{&INFOSTRUCTTMP.lineVec[0], &INFOSTRUCTTMP.lineVec[0]+9};  // Remove all the information after FORMAT and then change to sampleName_
                mergeVcfStruct_.headInfo += join(informationsVecTmp, "\t") + "\t" + sampleName_ + "\n";

                // Record the number of baseVcf columns
                mergeVcfStruct_.colNum = INFOSTRUCTTMP.lineVec.size();
            }
            else
            {
                mergeVcfStruct_.headInfo += INFOSTRUCTTMP.line + "\n";
            }
        }
        else
        {
            mergeVcfStruct_.startMap[INFOSTRUCTTMP.CHROM].push_back(INFOSTRUCTTMP.POS);  // Save the mutation origin location

            vector<string> informationsVecTmp{&INFOSTRUCTTMP.lineVec[0], &INFOSTRUCTTMP.lineVec[0]+8};  // Change FORMAT to GT and remove all the following information
            mergeVcfStruct_.BaseInfoMap[INFOSTRUCTTMP.CHROM][INFOSTRUCTTMP.POS] = join(informationsVecTmp, "\t") + "\tGT:SO:DP:ADP:NDP";  // Save the mutation informationsVecTmp information GT:software:depth:averageDepth:normalDepth

            // Get length information
            uint32_t refLen;
            vector<uint32_t> qryLenVec;
            tie(refLen, qryLenVec) = this->get_hap_len(
                INFOSTRUCTTMP.ID, 
                INFOSTRUCTTMP.REF, 
                INFOSTRUCTTMP.ALT, 
                {0, 0}, 
                "all"
            );

            // Save the ref length and qry length of the variation. qry is vector because there are multiple alleles.
            mergeVcfStruct_.refLenMap[INFOSTRUCTTMP.CHROM].push_back(refLen);
            mergeVcfStruct_.qryLenVecMap[INFOSTRUCTTMP.CHROM].push_back(qryLenVec);
        }
    }
}


/**
 * Get the length of the haplotype.
 *
 * @param svType                         Variation type
 * @param refSeq                         ref column information
 * @param qrySeqs                        qry Column information
 * @param gtVec                          Typing information of loci
 * @param lenType                        Take only the length corresponding to the haplotype or all the lengths (hap/all)
 * 
 * 
 * @return tuple<uint32_t, vector<uint32_t> >      tuple<refLen, vector<qryLen> >
**/
tuple<uint32_t, vector<uint32_t> > VCFMerge::get_hap_len(
    const string & svType, 
    const string & refSeq, 
    const string & qrySeqs, 
    const vector<int> & gtVec, 
    const string & lenType
)
{
    // Check that the mode is correct and exit the code incorrectly
    if (lenType != "hap" && lenType != "all") {
        cerr << "[" << __func__ << "::" << getTime() << "] " 
            << "Error: lenType -> " << lenType << endl;
        exit(1);
    }
    
    uint32_t refLen = refSeq.size();  // ref sequence length
    vector<string> qrySeqVec = split(qrySeqs, ",");  // qry sequence list
    
    // Check whether the index is out of bounds. If only hap length is needed, check again
    if (lenType == "hap") {
        int maxGtNum = *max_element(gtVec.begin(), gtVec.end());
        // First check whether the array is out of bounds
        if (static_cast<uint32_t>(maxGtNum) > qrySeqVec.size()) {
            cerr << "[" << __func__ << "::" << getTime() << "] " 
                << "Error: number of genotyping and ALT sequences do not match -> " 
                << qrySeqs << endl;
            exit(1);
        }
    }

    // Construct the length index common to ref and qry
    vector<uint32_t> seqLenVec;
    seqLenVec.push_back(refLen);

    // Traverse the allele list
    for (size_t i = 0; i < qrySeqVec.size(); i++) {
        const string& qrySeq = qrySeqVec[i];

        // Temporary storage length
        uint32_t refLenTmp = refLen;
        uint32_t qryLenTmp = qrySeq.size();

        // GraphTyper2 results
        if (qrySeq.find(">") != string::npos) {
            // Use regular expressions to extract length information
            std::regex reg("SVSIZE=(\\d+)");
            std::smatch match;
            // Check whether there is any length information in the qry sequence. If there is no length information, skip this site
            // <INS:SVSIZE=97:BREAKPOINT1>
            if (std::regex_search(qrySeq, match, reg)) {
                // The character segment contains inserts
                // <INS:SVSIZE=90:BREAKPOINT1>
                if (qrySeq.find("<INS") != string::npos && qrySeq.find("<DEL") == string::npos) {
                    refLenTmp = refLen;
                    qryLenTmp = std::stoul(match[1].str());;
                }
                // The character segment contains missing characters
                // <DEL:SVSIZE=1720:BREAKPOINT>
                else if (qrySeq.find("<INS") == string::npos && qrySeq.find("<DEL") != string::npos) {
                    refLenTmp = std::stoul(match[1].str());;
                    qryLenTmp = refLen;
                }
                // Character segment contains duplicate fields (GraphTyper2) <DUP:SVSIZE=2806:BREAKPOINT1>
                // <DUP:SVSIZE=10001:COVERAGE>
                else if (qrySeq.find("<DUP") != string::npos) {
                    refLenTmp = std::stoul(match[1].str());;
                    qryLenTmp = refLenTmp * 2;
                }
            } else {
                cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: No length information in the fourth column -> " << qrySeq << endl;
                refLenTmp = refLen;
                qryLenTmp = qrySeq.size();
            }

            seqLenVec[0] = refLenTmp; // Reset the length of the ref
        }

        // The result of BayesTyper was judged to be duplication, ref_len was 1-2, and qry_seq was very long
        // BayesTyper will change duplication into insertion, so recalculate the length
        if (svType.find("Duplication") != string::npos && refLenTmp <= 2) {
            refLenTmp = qryLenTmp;
            qryLenTmp *= 2;
        }

        // Add the length of qry
        // Judging that the haplotype is indeed in its place,
        if (seqLenVec.size() == (i + 1)) {
            // Add the length of qry
            seqLenVec.push_back(qryLenTmp);
        } else { // Index and list length do not match The Times error
            cerr << "[" << __func__ << "::" << getTime() << "] " 
                << "Error: wrong index for haplotype length -> " << qrySeqs << endl;
            exit(1);
        }
    }

    // Find the qry length corresponding to the genotype
    vector<uint32_t> qryLenVec;
    // Take only the sequence length of the haplotype
    if (lenType == "hap") {
        // There is only one gt, representing homozygous variants, and the two haplotypes add the same length
        if (gtVec.size() == 1) {
            // If genotype 0, skip this locus
            if (gtVec[0] == 0) {
                // Back '0/0'
                vector<uint32_t> qryLenVecTmp(seqLenVec[0], qrySeqVec.size());
                return make_tuple(seqLenVec[0], qryLenVecTmp);
            } else {
                qryLenVec.push_back(seqLenVec[gtVec[0]]);
                qryLenVec.push_back(seqLenVec[gtVec[0]]);
            }
        } else {
            for (auto gtTmp : gtVec) {
                qryLenVec.push_back(seqLenVec[gtTmp]);
            }
        }
    }
    // Take all the lengths
    else {
        for (size_t i = 1; i < seqLenVec.size(); i++) {
            qryLenVec.push_back(seqLenVec[i]);
        }
    }

    return make_tuple(seqLenVec[0], qryLenVec);
}


/**
 * Building index for different software.
 * 
 * 
 * @return void
**/

void VCFMerge::run_index_merge()
{
    vector<string> softwareVec = {ParagraphVcf_, MAPVcf_, GraphTyper2Vcf_, BayesTyperVcf_, GiraffeVcf_, GraphAlignerVcf_, PanGenieVcf_};
    vector<string> softwareNameVec = {"Paragraph", "VG-MAP", "GraphTyper2", "BayesTyper", "VG-Giraffe", "GraphAligner", "PanGenie"};

    for (size_t i = 0; i < softwareVec.size(); i++)
    {
        if (softwareVec[i].length() > 0)
        {
            check_vcf_sort(softwareVec[i]);  // Check whether the vcf file is sorted
            
            // Output specific indexes for software
            build_softwarefile_index(
                softwareVec[i], 
                softwareNameVec[i]
            );

            softwareNum_++;  // Number of software plus 1
        }
    }
}


/**
 * The results of the software are filtered and indexed, and the files are the output files of the software.
 *
 * @date 2023/07/09
 * 
 * @param vcfFileName        Software output vcf file
 * @param software           Software name
 * 
 * 
 * @return void
**/
void VCFMerge::build_softwarefile_index(
    const string & vcfFileName, 
    const string & software
)
{
    softwareVcfStruct softvcfStructure;  // Output struct

    softvcfStructure.software = software;  // Software name

    uint32_t sampleIdx = 0;  // Record which column the sample is in the vcf file

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Building index: " << software << endl;  // print log

    // input file stream
    VCFINFOSTRUCT INFOSTRUCTTMP;
    VCFOPEN VCFOPENCLASS(vcfFileName);

    while(VCFOPENCLASS.read(INFOSTRUCTTMP)) {
        // Comment line
        if (INFOSTRUCTTMP.line.find("#") != string::npos) {
            // If so, find the sample_name index
            if (INFOSTRUCTTMP.line.find("#CHROM") != string::npos) {
                // Gets the number of columns corresponding to sample
                if (software == "Paragraph") {  // Because paragraph keeps the original column, find sample after the original column  mergeVcfStruct_.colNum
                    sampleIdx = distance(INFOSTRUCTTMP.lineVec.begin(), find(INFOSTRUCTTMP.lineVec.begin()+mergeVcfStruct_.colNum, INFOSTRUCTTMP.lineVec.end(), sampleName_));  // Gets the index location of the sample
                } else {  // All the other programs start from column 10 and find FORMAT in column 9
                    sampleIdx = distance(INFOSTRUCTTMP.lineVec.begin(), find(INFOSTRUCTTMP.lineVec.begin()+9, INFOSTRUCTTMP.lineVec.end(), sampleName_));  // Gets the index location of the sample
                }
                
                // If not, report an error and exit the code
                if (sampleIdx == INFOSTRUCTTMP.lineVec.size()) {
                    cerr << "[" << __func__ << "::" << getTime() << "] " 
                        << "Error: '" << sampleName_ << "' is not in the output file of '" 
                        << software << "' -> " << INFOSTRUCTTMP.line 
                        << endl;
                    exit(1);
                }

                mergeVcfStruct_.softwateSampleIdx[software] = sampleIdx; // Add the sample index corresponding to the software
            }
        } else {  // Uncommented line
            // Check whether sample_name is found
            if (sampleIdx == 0) {
                cerr << "[" << __func__ << "::" << getTime() << "] " 
                    << "Error: '" << sampleName_ << "' is not in the output file of '" << software << "'"
                    << endl;
                exit(1);
            }
            
            // Obtain the coverage information of the site
            vector<float> depthVec = get_depth(
                INFOSTRUCTTMP.lineVec, 
                sampleIdx
            );
            float depSum = accumulate(depthVec.begin(), depthVec.end(), 0);  // Calculate the depth sum of all alleles
            softvcfStructure.depthVec.push_back(depSum);  // Add the vcf depth list corresponding to the software
            
            vector<int> gtVec = get_gt(
                INFOSTRUCTTMP.lineVec, 
                sampleIdx
            );
            string gt = join(gtVec, "/");

            // Filter by genotype
            if (gt == "0/0" || gt == "0" || gt == "." || gt == "./." || gtVec.size() == 0) {  // If it is (0/0,.) Format is skipped, or returns an empty list without building an index
                cerr << "[" << __func__ << "::" << getTime() << "] "
                    << "Warning: The genotype of the variant is empty, skip this site -> "
                    << INFOSTRUCTTMP.CHROM << "\t" 
                    << INFOSTRUCTTMP.POS << endl;
                continue;
            }

            // According to the FILTER field
            if (INFOSTRUCTTMP.FILTER != "PASS") {  // If it is not (PASS), it is skipped and no index is built
                continue;
            }

            // If it is not (PASS), it is skipped and no index is built
            int refLen;
            vector<uint32_t> qryLenVec;
            tie(refLen, qryLenVec) = this->get_hap_len(
                INFOSTRUCTTMP.ID, 
                INFOSTRUCTTMP.REF, 
                INFOSTRUCTTMP.ALT, 
                gtVec, 
                "hap"
            );

            // Save mutation initiation and typing information
            softvcfStructure.startMap[INFOSTRUCTTMP.CHROM].push_back(INFOSTRUCTTMP.POS);
            softvcfStructure.gtVecMap[INFOSTRUCTTMP.CHROM].push_back(gtVec);
            softvcfStructure.depthVecMap[INFOSTRUCTTMP.CHROM].push_back(depthVec);  // Software corresponding vcf depth (per allele)

            // Save the mutated refLen and qryLenVec
            softvcfStructure.refLenMap[INFOSTRUCTTMP.CHROM].push_back(refLen);
            softvcfStructure.qryLenVecMap[INFOSTRUCTTMP.CHROM].push_back(qryLenVec);
        }
    }

    // Calculate the average coverage, variance, and standard deviation of the software
    float aveDepth;
    float variance;
    float sd;
    tie(aveDepth, variance, sd) = cal_var_sd(softvcfStructure.depthVec);
    get<0>(mergeVcfStruct_.depthMap[software]) = aveDepth;
    get<1>(mergeVcfStruct_.depthMap[software]) = variance;
    get<2>(mergeVcfStruct_.depthMap[software]) = sd;

    // Add the results of the software to the diagram
    vcf_merge(softvcfStructure);
}


// paragraph DP -> 1
// graphaligner, vg-map- vg-giraffe DP -> 6
// bayestyper MAC -> -1,1.87332
// graphtyper DP -> 6
// pangenie KC -> 4
/**
 * Get site DP.
 *
 * @param informationsVec     vcfInfoVec
 * @param sampleIdx           sample corresponding column
 * 
 * 
 * @return depthVec        vector<depth>
**/
vector<float> VCFMerge::get_depth(
    const vector<string> & informationsVec, 
    const uint32_t & sampleIdx
) {
    vector<float> depthVec;  // vector of site coverage

    // FORMAT field split
    vector<string> formatVec = split(informationsVec[8], ":");

    uint32_t depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "DP"));  // Gets the index position of depth

    // BayesTyper software does not have DP fields, so it uses MAC fields instead
    if (depthIndex == formatVec.size()) {
        depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "MAC"));
    }
    // PanGenie software does not have a DP field, so the KC field is used instead
    if (depthIndex == formatVec.size()) {
        depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "KC"));
    }
    
    // Check whether index exists. If it does not exist, return depth 0.
    if (depthIndex == formatVec.size()) {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [DP,MAC,KC] information in FORMAT -> " << informationsVec[0] << ":" << informationsVec[1] << endl;
        depthVec = {0, 0};
    }
    // If it exists, save it
    else {
        vector<string> splitResult = split(informationsVec[sampleIdx], ":");

        // Check if the array is out of bounds
        if (depthIndex < splitResult.size()) {
            auto depthSplit = split(splitResult[depthIndex], ",");
            for (auto it : depthSplit) {
                // BayesTyper's -1 means not found, so change -1 to 0
                if (it == "-1") {
                    it = "0";
                }
                // Prevent error in stof(it) conversion
                try {
                    depthVec.push_back(stof(it));
                } catch (const std::exception& e) {
                    cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: stof(it) conversion failed. Replaced with {0,0} -> " << it << endl;
                    depthVec = {0, 0};
                }
            }
        }
        else {
            cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [DP,MAC,KC] information in column " << sampleIdx << " -> " << informationsVec[sampleIdx] << endl;
            depthVec = {0, 0};
        }
    }

    return depthVec;
}


/**
 * Get a list of loci genotypes.
 *
 * @param informationsVec  vcfInfoList
 * @param sampleIdx        Index of the sample genotype, with the default value 0 representing the last column
 * 
 * 
 * @return gtVec           vector <int>
**/
vector<int> VCFMerge::get_gt(
    const vector<string> & informationsVec, 
    uint32_t sampleIdx
) {
    vector<int> gtVec;  // Locus typing vector

    // FORMAT character split
    vector<string> formatVec = split(informationsVec[8], ":");

    uint32_t gtIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "GT"));  // Gets the index location of GT

    // // Determine whether the index exists. If it does not exist, the genotypes are all 0.
    if (gtIndex == formatVec.size()) {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [GT] information in FORMAT -> " << informationsVec[0] << ":" << informationsVec[1] << endl;
        gtVec = {0, 0};
    }
    // If it exists, save it
    else {
        string gt;  // Store the genotype field

        // The number of columns not specified is the last column
        if (sampleIdx == 0) {
            gt = split(informationsVec.back(), ":")[gtIndex];  // gt field
        }
        else {
            gt = split(informationsVec[sampleIdx], ":")[gtIndex];  // gt field
        }
        
        string splitStr;  // Delimiter in gt
        // Determine the '/' separator
        if (gt.find("/") != string::npos) {
            splitStr = "/";
        }
        // Determine that '|' is the separator
        else if (gt.find("|") != string::npos) {
            splitStr = "|";
        }
        // Return a null value if you do not know
        else {
            gtVec = {0, 0};
            return gtVec;
        }
        
        // Once you find gt, split it by splitStr and loop
        auto splitResult = split(gt, splitStr);
        for (auto it : splitResult) {
            // If it is '.', skip this site
            if (it == ".") {
                gtVec = {0, 0};
                return gtVec;
            }
            // Prevent error in stof(it) conversion
            try {
                gtVec.push_back(stoi(it));  // If it is '.', skip this site
            } catch (const std::exception& e) {
                cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: stof(it) conversion failed. Replaced with {0,0} -> " << it << endl;
                gtVec = {0, 0};
                return gtVec;
            }
        }
    }

    return gtVec;
}



/**
 * vcf_merge Function added to the total map after recall
 *
 * @date 2023/07/09
 * 
 * @param chromosome         Chromosome number
 * @param trueRefStart       The actual ref starting position
 * @param software           software
 * @param qryLenVec          The haplotype of software typing corresponds to the length
 * @param gtVec              Classification gt list of software
 * @param gt                 The current cycle of gt
 * @param depth              The depth corresponding to the site
 * @param j                  Index of multiple haplotype loops of software
 * @param k                  Binary search method index of two coordinate loops
 * @param l                  Cyclic index of true site haplotype
 * @param indexLeft          Left index of binary search method
 * @param indexRight         Right index of binary search method
 * 
 * 
 * @return tuple<int, int>   tuple<state, j>  0 -> Add correctly; -1 -> The next loop is required
**/
tuple<int, int> VCFMerge::recall_push(
    const string chromosome, 
    const uint32_t trueRefStart, 
    const string software, 
    const vector<uint32_t> qryLenVec, 
    const vector<int> gtVec, 
    const int gt, 
    const float depth, 
    uint32_t j, 
    uint32_t k,
    uint32_t l,
    int64_t & indexLeft, 
    int64_t & indexRight
)
{
    // First initialize the recall hash table
    if (mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome].find(trueRefStart) == mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome].end()) {  // Initialize if the starting position is first seen
        mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart];
    }
    if (mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart].find(software) == mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart].end()) {  // If the software is first seen, it is initialized
        vector<float> depthVecTmp(qryLenVec.size());
        vector<int> gtVecTmp(qryLenVec.size());
        mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software] = make_tuple(depthVecTmp, gtVecTmp);
    }

    // If one of gt and l is 0, but the other is not, the next loop will be performed to prevent SNP from making an error in its judgment
    if ((gt != 0 && l == 0) || (gt == 0 && l != 0)) {
        return make_tuple(-1, j);
    } else {
        // Each haplotype is added separately
        get<0>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = depth;  // Corresponding haplotype position depth
        get<1>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = l;  // Corresponding haplotype location genotype

        // Change the coordinates of the binary search, and the next allele is added directly to the refStart
        indexLeft = k; 
        indexRight = k;

        if (j == 0 && gt == gtVec[1]) {  // If the two haplotypes are the same, assign the value directly and skip the next loop
            j++;
            get<0>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = depth;  // Corresponding haplotype position depth
            get<1>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = l;  // Corresponding haplotype location genotype
        }
    }

    return make_tuple(0, j);
}


/**
 * The results of the software are filtered and indexed, and the files are the output files of the software.
 *
 * @date 2023/07/09
 * 
 * @param softvcfStructure   build_softwarefile_index Indicates the index of the built software vcf
 * 
 * @return void
**/
void VCFMerge::vcf_merge(
    softwareVcfStruct & softvcfStructure
) {
    vector<string> chromosomeVec;
    string software = softvcfStructure.software;

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Merging: " << software << ".\n";  // print log

    for (auto iter = mergeVcfStruct_.startMap.begin(); iter != mergeVcfStruct_.startMap.end(); iter++) {
        chromosomeVec.push_back(iter->first);
    }

    // for (auto iter = softvcfStructure.startMap.begin(); iter != softvcfStructure.startMap.end(); iter++) {  // Loop software vcf (Chromosome)
    for (const auto& [chromosome, startVec] : softvcfStructure.startMap) {  // Loop software vcf (Chromosome)
        const vector<uint32_t>& refLenVec = softvcfStructure.refLenMap[chromosome];
        const vector<vector<uint32_t> >& qryLenVecVec = softvcfStructure.qryLenVecMap[chromosome];
        const vector<vector<int> >& gtVecVec = softvcfStructure.gtVecMap[chromosome];
        const vector<vector<float> >& depthVecVec = softvcfStructure.depthVecMap[chromosome];

        // First initialize the recall hash table
        if (mergeVcfStruct_.recallSoftwareGtDepVecMap.find(chromosome) == mergeVcfStruct_.recallSoftwareGtDepVecMap.end()) {  // If the chromosome is first seen, it is initialized
            mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome];
        }

        if (find(chromosomeVec.begin(), chromosomeVec.end(), chromosome) == chromosomeVec.end()) {  // First check if there is this chromosome in mergeVcfStructure, if not, report an error and exit the code
            cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: chromosome is not present in '"<< trueVcf_ << "' -> " << chromosome << endl;
            exit(1);
        } else {  // If it exists, use binary search to find the most recent variation and determine whether they are the same, push if they are, and add a new one if they are not
            const vector<uint32_t>& mergeRefStartVec = mergeVcfStruct_.startMap[chromosome];
            const vector<uint32_t>& mergeRefLenVec = mergeVcfStruct_.refLenMap[chromosome];
            const vector<vector<uint32_t> >& mergeQryLenVecVec = mergeVcfStruct_.qryLenVecMap[chromosome];  // vector<vector<qryLen>>

            for (size_t i = 0; i < startVec.size(); i++) {  // Loop software vcf (location)
                uint32_t refStart = startVec[i];
                uint32_t refLen = refLenVec[i];
                vector<uint32_t> qryLenVec = qryLenVecVec[i];  // Allele sequence length corresponding to locus typing
                vector<int> gtVec = gtVecVec[i];  // Locus typing corresponding to typing
                vector<float> depthVec = depthVecVec[i];  // Allelic depth corresponding to locus typing

                // Record binary search index, multiple alleles with the same refStart
                int64_t indexLeft = -1;
                int64_t indexRight = -1;

                // Traversal of multiple alleles
                for (size_t j = 0; j < qryLenVec.size(); j++) {
                    uint32_t qryLen = qryLenVec[j];
                    int gt = gtVec[j];
                    float depth = depthVec[j];

                    // Binary search method to find the variation index within 200/10bp.
                    if (indexLeft == -1 && indexRight == -1) {  // New alleles were searched again
                        if (refLen <= 49 && qryLen <= 49) {
                            indexLeft = search_Binary_left(mergeRefStartVec, (refStart-10));
                            indexRight = search_Binary_right(mergeRefStartVec, (refStart+10));
                        } else {
                            indexLeft = search_Binary_left(mergeRefStartVec, (refStart-200));
                            indexRight = search_Binary_right(mergeRefStartVec, (refStart+200));
                        }

                        if (indexLeft < 0 || indexRight >= mergeRefStartVec.size()) {
                            cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: out of index, please check the data or code.\n";
                            exit(1);
                        }
                    }

                    for (int64_t k = indexLeft; k <= indexRight; k++) {
                        // true Indicates the mutation information
                        vector<uint32_t> mergeQryLenVec = mergeQryLenVecVec[k];  // The length of multiple alleles
                        uint32_t trueRefLen = mergeRefLenVec[k];
                        uint32_t trueRefStart = mergeRefStartVec[k];

                        // Construct the length index common to ref and qry
                        vector<uint32_t> trueSeqLenVec;
                        trueSeqLenVec.push_back(trueRefLen);  // Start by adding the length of the reference genome
                        trueSeqLenVec.insert(trueSeqLenVec.end(), mergeQryLenVec.begin(), mergeQryLenVec.end());  // readd

                        // If the length is 0, an error is reported and the code exits.
                        if (mergeQryLenVec.size() == 0) {
                            cerr << "[" << __func__ << "::" << getTime() << "] " 
                                << "Error: mergeQryLenVec.size() == 0 -> " << chromosome 
                                << " " << mergeRefStartVec[k] << endl;
                            exit(1);
                        }

                        for (size_t l = 0; l < trueSeqLenVec.size(); l++) {  // When a locus has multiple alleles, trueSeqLenVec stores the length of each allele, so it iterates over it to see if the mutation at that locus is the same as the one in the merge, which contains 0
                            uint32_t trueQryLen = trueSeqLenVec[l];

                            // deletion
                            if (refLen >= 50 && qryLen < 50) {
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart)) <= 200) &&
                                    (abs((static_cast<int32_t>(refStart + refLen) - static_cast<int32_t>(trueRefStart + trueRefLen)) <= 200)) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen)) / (float)trueRefLen) <= 0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen < 50 && qryLen >= 50) {  // ins
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=200) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=200) &&
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }

                                    goto stop;
                                }
                            }
                            else if (refLen >= 50 && qryLen >= 50) {  // Replace
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=200) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=200) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen == 1 && qryLen == 1) {  // snp
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=1) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=1) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen >= 3 && qryLen <= 2) {  // del
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=10) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=10) &&
                                ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen <= 2 && qryLen >= 3) {  // ins
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=10) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=10) &&
                                ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else {
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=1) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=1) &&
                                ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // Added to the general picture
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // No addition is followed by the next loop
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            }
                        }
                    }
                    stop:; // If found, exit the nested loop. End the cycle of this haplotype and proceed to the next haplotype
                }
            }
        }
    }
}


/**
 * Get the length information of the variation
 *
 * @param vcfInfo           vcfInfo
 * @param gtVec             Genotype list
 * 
 * 
 * @return int              svLength
**/
int64_t VCFMerge::sv_length_select(
    const string & vcfInfo, 
    const vector<int> & gtVec
) {
    int64_t svLength = 0;

    vector<string> vcfInfoVec = split(vcfInfo, "\t");

    // Gets the length of the ref and haplotype
    uint32_t refLen;
    vector<uint32_t> qryLenVec;
    tie(refLen, qryLenVec) = this->get_hap_len(
        vcfInfoVec[2], 
        vcfInfoVec[3], 
        vcfInfoVec[4], 
        gtVec, 
        "hap"
    );

    for (size_t i = 0; i < gtVec.size(); i++) {
        if (gtVec[i] == 0) {  // If genotype is 0, skip
            continue;
        }
        else {
            svLength = static_cast<int64_t>(qryLenVec[i] - refLen);
        }
    }
    
    return svLength;
}



/**
 * Filter result according to the depth and number of variants.
 *
 * @param gtAllVec        vector of all gt sites
 * @param softwareVec     Locus vector of all software
 * @param depthNorVec     The vector of all normalized depths at the site
 * @param vcfInfo         Variation information at the site
 * 
 * @return software
**/
string VCFMerge::filter_rule(
    vector<vector<int> > & gtAllVec, 
    vector<string> & softwareVec, 
    vector<float> & depthNorVec, 
    const string & vcfInfo
) {
    // Result filtering
    vector<string> bestSoftwareVec{};  // The most frequently appearing software vector
    string selectSoftware;  // Software vector after filtering according to the length of sv
    int64_t svLength{};
    int gtFrequency = 0;

    // The index whose depth is closest to 0 after standardization
    float selectDepth = 10000.0;
    int selectDepthIdx = -1;
    for (size_t i = 0; i < depthNorVec.size(); i++) {
        if (abs(depthNorVec[i]) < selectDepth) {
            selectDepth = abs(depthNorVec[i]);  // Renewal depth
            selectDepthIdx = i;  // Update index
        }
    }

    // Calculate the frequency of occurrence of each genotype
    // Find the gt with the highest frequency first
    for (size_t i = 0; i < gtAllVec.size(); i++) {
        svLength = sv_length_select(
            vcfInfo, 
            gtAllVec[i]
        );

        if (count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]) > gtFrequency) {
            gtFrequency = count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]);
        }
    }

    // Find out the gt corresponding software with the highest frequency
    for (size_t i = 0; i < gtAllVec.size(); i++) {
        if (count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]) == gtFrequency) {
            bestSoftwareVec.push_back(softwareVec[i]);
        }
    }

    // Filter rule
    if (-49 <= svLength && svLength <= 49) {  // snp+indel
        if (mode_ == "specific") {  // Is a strain specific vcf file
            if (gtFrequency < 2) {  // The number of supported software is less than 2, and the genotype whose depth is closest to 0 is selected
                selectSoftware = softwareVec[selectDepthIdx];  // Select software with coverage close to 0
            } else {  // Results If there are more than two software support, select this genotype.
                selectSoftware = bestSoftwareVec[0]; // Select the most frequent results
            }
        } else {  // vcf for composition
        
            if (gtFrequency < 2) {  // The result must be supported by more than two software, otherwise the site is skipped
                selectSoftware.clear();
            } else {  // Results If there are more than two software support, select this genotype.
                selectSoftware = bestSoftwareVec[0]; // Select the most frequent results
            }
        }
    } else {  // Insertion and Deletion
        vector<string> softwareSortVec = {"BayesTyper", "Paragraph", "VG-MAP", "VG-Giraffe", "GraphTyper2", "GraphAligner", "PanGenie"};
        for (auto it : softwareSortVec) {
            // If there is it support in the variation greater than 50bp, the result of it is directly selected
            if (find(softwareVec.begin(), softwareVec.end(), it) != softwareVec.end()) {
                selectSoftware = it;
                break;
            } else {  // Otherwise, select software with coverage close to 0
                selectSoftware = softwareVec[selectDepthIdx];  // Select software with coverage close to 0
            }
        }
    }

    return selectSoftware;
}



/*
 * Select software with coverage close to 0
 * mergeVcfStruct_ -> struct after software merger
*/

/**
 * Filter and merge result according to the depth and number of variants.
 *
 * @param mode_               EVG running mode
 * 
 * @return void
**/
void VCFMerge::vcf_merge_filter()
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Filtering.\n";

    // Iterate over the recall hash table
    for (const auto& [chromosome, startSoftwareInfoMap] : mergeVcfStruct_.recallSoftwareGtDepVecMap) {  // map<chr, map<start, map<software, tuple<vector<depth>, vector<gt> > > > >
        for (const auto& [refStart, SoftwareInfoMap] : startSoftwareInfoMap) {  // map<start, map<software, tuple<vector<depth>, vector<gt> > > >
            // vcfInfo at this site
            string informations = mergeVcfStruct_.BaseInfoMap[chromosome][refStart];

            // Constructs the parameters of filter_rule
            vector<vector<int>> gtAllVec;
            vector<string> softwareVec;
            vector<float> depthSumVec;
            vector<float> depthNorVec;
            vector<vector<float> > depthVecVec;

            for (const auto& [software, Info] : SoftwareInfoMap) {  // map<software, tuple<vector<depth>, vector<gt> > >
                depthVecVec.push_back(get<0>(Info));

                // Obtain the average coverage of the software. Check whether the map contains it. If no, an error is reported
                float meanDepth;
                float sd;
                if (mergeVcfStruct_.depthMap.find(software) != mergeVcfStruct_.depthMap.end()) {
                    meanDepth = get<0>(mergeVcfStruct_.depthMap[software]);
                    sd = get<2>(mergeVcfStruct_.depthMap[software]);
                } else {
                    cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: no coverage information -> "<< software << endl;
                    exit(1);
                }
                float depthSumTmp = accumulate(get<0>(Info).begin(), get<0>(Info).end(), 0);  // Calculate the depth sum of all alleles
                depthSumVec.push_back(depthSumTmp);
                
                // Standardization of coverage (z-score standardization)
                float depthNor = (depthSumTmp - meanDepth) / (float)sd;
                
                gtAllVec.push_back(get<1>(Info));
                softwareVec.push_back(software);
                depthNorVec.push_back(depthNor);
            }

            // Filter to select the most likely haplotype
            string selectSoftware = filter_rule(
                gtAllVec, 
                softwareVec, 
                depthNorVec, 
                informations
            );

            if (selectSoftware.empty()) {  // If an empty string is returned, the site is untrusted and is skipped
                continue;
            }

            // Selected software indexes, genotypes and in-depth information
            int softwareIdx = distance(softwareVec.begin(), find(softwareVec.begin(), softwareVec.end(), selectSoftware));  // Gets the index location of the software
            vector<int> selectGtVec = gtAllVec[softwareIdx];
            float selectDepthSumVec = depthSumVec[softwareIdx];
            float selectDepthNor = depthNorVec[softwareIdx];
            vector<float> selectDepthVec = depthVecVec[softwareIdx];

            // // save result
            string selectGt = join(selectGtVec, "/");
            selectGt += ":" + selectSoftware 
                    + ":" + to_string(selectDepthNor).substr(0, 5) 
                    + ":" + to_string(get<0>(mergeVcfStruct_.depthMap[selectSoftware])).substr(0, 5) 
                    + ":" + to_string(selectDepthSumVec).substr(0, 5);
            outChrStartInfoMap_[chromosome][refStart] = informations + "\t" + selectGt;
        }
    }
}



/**
 * Calculate the variance and standard deviation
 *
 * @param data     List with site depth
 * 
 * @return tuple   make_tuple(mean, variance, std_deviation)
**/
tuple<float, float, float> VCFMerge::cal_var_sd(const vector<float>& data)
{
    float sum = std::accumulate(std::begin(data), std::end(data), 0.0);
    float mean = sum / data.size();

    float variance = 0.0;
    std::for_each(std::begin(data), std::end(data), [&](const float d) {
        variance += pow(d-mean, 2);
    });
    variance /= data.size();

    float std_deviation = sqrt(variance);

    return make_tuple(mean, variance, std_deviation);
}


/**
 * save result
 * mergeVcfStruct_ -> struct after software merger
 * outChrStartInfoMap_ -> vcf_merge_filter Output result   outChrStartInfoMap_[chromosome][refStart][refLen][qryLen]
 * prefix -> Output file name prefix
**/

/**
 * save result
 *
 * 
 * @return void
**/
void VCFMerge::result_save(
)
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Wrote genotyped variants to '" << outputFileName_ << "'\n";

    SAVE SaveClass(outputFileName_);

    // Output file name prefix
    string outTxt = mergeVcfStruct_.headInfo;
 
    for (const auto& [_, StartInfoMap] : outChrStartInfoMap_) {  // outChrStartInfoMap_<chromosome, map<refStart, vcfInfo> >
        for (const auto& [_, info] : StartInfoMap) {  // map<refStart, vcfInfo>
            outTxt += info + "\n";
        }
    }

    SaveClass.save(outTxt);
}