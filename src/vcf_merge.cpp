// g++ vcf_merge_depth.cpp -o vcf_merge_depth -lz

#include "../include/vcf_merge.hpp"

using namespace std;

int main_merge(int argc, char** argv)
{
    // EVG的运行模式
    string mode = "specific";

    string trueVcf;
    string ParagraphVcf;
    string GraphTyper2Vcf;
    string BayesTyperVcf;
    string mapVcf;
    string giraffeVcf;
    string GraphAlignerVcf;
    string PanGenieVcf;

    // 样本名称
    string sampleName = "";

    // 输出文件名字
    string outputFileName = "";

    // 输入参数
    int c;
    
    while (true)
    {
        static const struct option long_options[] = {
            {"vcf", required_argument, 0, 'v'},
            {"Paragraph", required_argument, 0, '1'},
            {"GraphTyper2", required_argument, 0, '2'},
            {"BayesTyper", required_argument, 0, '3'},
            {"VG-MAP", required_argument, 0, '4'},
            {"VG-Giraffe", required_argument, 0, '5'},
            {"GraphAligner", required_argument, 0, '6'},
            {"PanGenie", required_argument, 0, '7'},
            {"name", required_argument, 0, 'n'},

            {"mode", required_argument, 0, 'm'},
            {"out", required_argument, 0, 'o'},
            {"help", no_argument, 0, 'h'},
            {0, 0, 0, 0}
        };

        int option_index = 0;

        c = getopt_long (argc, argv, "v:1:2:3:4:5:6:7:n:m:o:h", long_options, &option_index);

        if (c == -1)
            break;
        
        switch (c)
        {
        case 'v':
            trueVcf = optarg;
            break;
        case '1':
            ParagraphVcf = optarg;
            break;
        case '2':
            GraphTyper2Vcf = optarg;
            break;
        case '3':
            BayesTyperVcf = optarg;
            break;
        case '4':
            mapVcf = optarg;
            break;
        case '5':
            giraffeVcf = optarg;
            break;
        case '6':
            GraphAlignerVcf = optarg;
            break;
        case '7':
            PanGenieVcf = optarg;
            break;
        case 'n':
            sampleName = optarg;
            break;
        case 'm':
            mode = optarg;
            break;
        case 'o':
            outputFileName = optarg;
            break;
        case 'h':
        case '?':
            help_merge(argv);
            exit(1);
            break;
        default:
            abort ();
        }
    }

    if (argc <= 2) {
        help_merge(argv);
        return 1;
    }

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Running ...\n";

    // 检查参数
    if (mode != "specific" && mode != "all")
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Mode error: specific/all." << endl;
        help_merge(argv);
        exit(1);
    }
    if (sampleName.size() == 0)
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Empty sample name: -n." << endl;
        help_merge(argv);
        exit(1);
    }


    // init 
    VCFMerge VCFMerge(
        mode, 
        trueVcf, 
        ParagraphVcf, 
        GraphTyper2Vcf, 
        BayesTyperVcf, 
        mapVcf, 
        giraffeVcf, 
        GraphAlignerVcf, 
        PanGenieVcf, 
        sampleName, 
        outputFileName
    );

    // build base index
    VCFMerge.build_basefile_index();

    // build software index
    VCFMerge.run_index_merge();

    // filter
    VCFMerge.vcf_merge_filter();

    // save
    VCFMerge.result_save();


    cerr << "[" << __func__ << "::" << getTime() << "] " << "Done ...\n";

    return 0;
}

// 帮助文档
void help_merge(char** argv)
{
  cerr << "usage: " << argv[0] << " " << argv[1] << " -v [options]" << endl
       << "merge VCF files generated by genome graph software." << endl
       << endl
       << "required arguments (Note: vcf files must be sorted):" << endl
       << "    -v, --vcf            FILE      base vcf file for genotyping" << endl
       << "    --Paragraph          FILE      output file of Paragraph" << endl
       << "    --GraphTyper2        FILE      output file of GraphTyper2" << endl
       << "    --BayesTyper         FILE      output file of BayesTyper" << endl
       << "    --VG-MAP             FILE      output file of VG-MAP" << endl
       << "    --VG-Giraffe         FILE      output file of VG-Giraffe" << endl
       << "    --GraphAligner       FILE      output file of GraphAligner" << endl
       << "    --PanGenie           FILE      output file of PanGenie" << endl
       << "    -n, --name           STRING    used to extract genotyping result, after the FORMAT of vcf" << endl
       << endl
       << "optional arguments:" << endl
       << "    -m, --mode           STRING    software mode (specific/all) [specific]" << endl
       << "    -o, --out            FILE      output filename [stdout]" << endl
       << endl
       << "    -h, --help                     print this help document" << endl;
}


/**
 * init
 *
 * @param mode
 * @param trueVcf
 * @param ParagraphVcf
 * @param GraphTyper2Vcf
 * @param BayesTyperVcf
 * @param MAPVcf
 * @param GiraffeVcf
 * @param GraphAlignerVcf
 * @param PanGenieVcf
 * @param sampleName         Sample names to be merged
 * 
**/
VCFMerge::VCFMerge(
    const string& mode,
    const string& trueVcf, 
    const string& ParagraphVcf, 
    const string& GraphTyper2Vcf, 
    const string& BayesTyperVcf, 
    const string& MAPVcf, 
    const string& GiraffeVcf, 
    const string& GraphAlignerVcf, 
    const string& PanGenieVcf, 
    const string& sampleName, 
    const string& outputFileName
) : mode_(mode), trueVcf_(trueVcf), ParagraphVcf_(ParagraphVcf), GraphTyper2Vcf_(GraphTyper2Vcf), 
    BayesTyperVcf_(BayesTyperVcf), MAPVcf_(MAPVcf), GiraffeVcf_(GiraffeVcf), 
    GraphAlignerVcf_(GraphAlignerVcf), PanGenieVcf_(PanGenieVcf), sampleName_(sampleName), 
    outputFileName_(outputFileName)
{
    if (trueVcf_.empty())
    {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Please enter the -v/--vcf parameter" << endl;
        exit(1);
    }
}


/**
 * 构件base文件索引，不对vcf进行过滤，用于创建基准index。文件为真实的vcf文件
 * 
 * 
 * @return void
**/
void VCFMerge::build_basefile_index()
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Building index: '" << trueVcf_ << "'" << endl;

    check_vcf_sort(trueVcf_);

     // input file stream
    VCFINFOSTRUCT INFOSTRUCTTMP;
    VCFOPEN VCFOPENCLASS(trueVcf_);

    while(VCFOPENCLASS.read(INFOSTRUCTTMP))
    {
        if (INFOSTRUCTTMP.line.find("#") != string::npos)  // 注释行
        {
            // #CHROM注释行索引
            if (INFOSTRUCTTMP.line.find("#CHROM") != string::npos)
            {
                vector<string> informationsVecTmp{&INFOSTRUCTTMP.lineVec[0], &INFOSTRUCTTMP.lineVec[0]+9};  // 将FORMAT后边的信息全部去掉，然后改为 sampleName_
                mergeVcfStruct_.headInfo += join(informationsVecTmp, "\t") + "\t" + sampleName_ + "\n";

                // 记录baseVcf的列数
                mergeVcfStruct_.colNum = INFOSTRUCTTMP.lineVec.size();
            }
            else
            {
                mergeVcfStruct_.headInfo += INFOSTRUCTTMP.line + "\n";
            }
        }
        else
        {
            mergeVcfStruct_.startMap[INFOSTRUCTTMP.CHROM].push_back(INFOSTRUCTTMP.POS);  // 保存变异起始位置

            vector<string> informationsVecTmp{&INFOSTRUCTTMP.lineVec[0], &INFOSTRUCTTMP.lineVec[0]+8};  // 将FORMAT改成GT，后边的信息全部去掉
            mergeVcfStruct_.BaseInfoMap[INFOSTRUCTTMP.CHROM][INFOSTRUCTTMP.POS] = join(informationsVecTmp, "\t") + "\tGT:SO:DP:ADP:NDP";  // 保存变异informationsVecTmp信息 GT:software:depth:averageDepth:normalDepth

            // 获取长度信息
            uint32_t refLen;
            vector<uint32_t> qryLenVec;
            tie(refLen, qryLenVec) = this->get_hap_len(
                INFOSTRUCTTMP.ID, 
                INFOSTRUCTTMP.REF, 
                INFOSTRUCTTMP.ALT, 
                {0, 0}, 
                "all"
            );

            // 保存变异的ref长度和qry长度。qry为vector，因为有多个等位基因。
            mergeVcfStruct_.refLenMap[INFOSTRUCTTMP.CHROM].push_back(refLen);
            mergeVcfStruct_.qryLenVecMap[INFOSTRUCTTMP.CHROM].push_back(qryLenVec);
        }
    }
}


/**
 * 获取单倍型对应的长度信息.
 *
 * @param svType                         变异类型
 * @param refSeq                         ref列信息
 * @param qrySeqs                        qry列信息
 * @param gtVec                          位点的分型信息
 * @param lenType                        只取单倍型对应的长度还是所有的长度(hap/all)
 * 
 * 
 * @return tuple<uint32_t, vector<uint32_t> >      tuple<refLen, vector<qryLen> >
**/
tuple<uint32_t, vector<uint32_t> > VCFMerge::get_hap_len(
    const string & svType, 
    const string & refSeq, 
    const string & qrySeqs, 
    const vector<int> & gtVec, 
    const string & lenType
)
{
    // 检查模式是否正确，不正确退出代码
    if (lenType != "hap" && lenType != "all") {
        cerr << "[" << __func__ << "::" << getTime() << "] " 
            << "Error: lenType -> " << lenType << endl;
        exit(1);
    }
    
    uint32_t refLen = refSeq.size();  // ref序列长度
    vector<string> qrySeqVec = split(qrySeqs, ",");  // qry的序列列表
    
    // 检查索引是否越界，如果只要hap的长度时候再检查
    if (lenType == "hap") {
        int maxGtNum = *max_element(gtVec.begin(), gtVec.end());
        // 先检查是否数组是否越界
        if (static_cast<uint32_t>(maxGtNum) > qrySeqVec.size()) {
            cerr << "[" << __func__ << "::" << getTime() << "] " 
                << "Error: number of genotyping and ALT sequences do not match -> " 
                << qrySeqs << endl;
            exit(1);
        }
    }

    // 构造ref和qry共同的长度索引
    vector<uint32_t> seqLenVec;
    seqLenVec.push_back(refLen);

    // 遍历等位基因列表
    for (size_t i = 0; i < qrySeqVec.size(); i++) {
        const string& qrySeq = qrySeqVec[i];

        // 临时存储长度
        uint32_t refLenTmp = refLen;
        uint32_t qryLenTmp = qrySeq.size();

        // GraphTyper2的结果
        if (qrySeq.find(">") != string::npos) {
            // 使用正则表达式提取长度信息
            std::regex reg("SVSIZE=(\\d+)");
            std::smatch match;
            // 检查qry序列中有没有长度信息，没有的话跳过该位点
            // <INS:SVSIZE=97:BREAKPOINT1>
            if (std::regex_search(qrySeq, match, reg)) {
                // 字符段中包含插入
                // <INS:SVSIZE=90:BREAKPOINT1>
                if (qrySeq.find("<INS") != string::npos && qrySeq.find("<DEL") == string::npos) {
                    refLenTmp = refLen;
                    qryLenTmp = std::stoul(match[1].str());;
                }
                // 字符段中包含缺失
                // <DEL:SVSIZE=1720:BREAKPOINT>
                else if (qrySeq.find("<INS") == string::npos && qrySeq.find("<DEL") != string::npos) {
                    refLenTmp = std::stoul(match[1].str());;
                    qryLenTmp = refLen;
                }
                // 字符段中包含重复的字段（GraphTyper2）<DUP:SVSIZE=2806:BREAKPOINT1>
                // <DUP:SVSIZE=10001:COVERAGE>
                else if (qrySeq.find("<DUP") != string::npos) {
                    refLenTmp = std::stoul(match[1].str());;
                    qryLenTmp = refLenTmp * 2;
                }
            } else {
                cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: No length information in the fourth column -> " << qrySeq << endl;
                refLenTmp = refLen;
                qryLenTmp = qrySeq.size();
            }

            seqLenVec[0] = refLenTmp; // 重置ref的长度
        }

        // 判断BayesTyper的结果为duplication，且ref_len为1-2，qry_seq却很长时
        // BayesTyper会把duplication变成插入，所以重新计算长度
        if (svType.find("Duplication") != string::npos && refLenTmp <= 2) {
            refLenTmp = qryLenTmp;
            qryLenTmp *= 2;
        }

        // 添加qry的长度
        // 判断单倍型确实在自己的位置上，
        if (seqLenVec.size() == (i + 1)) {
            // 添加qry的长度
            seqLenVec.push_back(qryLenTmp);
        } else { // 索引和列表长度不符合时报错
            cerr << "[" << __func__ << "::" << getTime() << "] " 
                << "Error: wrong index for haplotype length -> " << qrySeqs << endl;
            exit(1);
        }
    }

    // 找基因型对应的qry长度
    vector<uint32_t> qryLenVec;
    // 只取单倍型的序列长度
    if (lenType == "hap") {
        // gt只有一个，代表为纯合的变异，两个单倍型添加一样的长度
        if (gtVec.size() == 1) {
            // 如果基因型为0，跳过该位点
            if (gtVec[0] == 0) {
                // 返回 '0/0'
                vector<uint32_t> qryLenVecTmp(seqLenVec[0], qrySeqVec.size());
                return make_tuple(seqLenVec[0], qryLenVecTmp);
            } else {
                qryLenVec.push_back(seqLenVec[gtVec[0]]);
                qryLenVec.push_back(seqLenVec[gtVec[0]]);
            }
        } else {
            for (auto gtTmp : gtVec) {
                qryLenVec.push_back(seqLenVec[gtTmp]);
            }
        }
    }
    // 取所有的长度
    else {
        for (size_t i = 1; i < seqLenVec.size(); i++) {
            qryLenVec.push_back(seqLenVec[i]);
        }
    }

    return make_tuple(seqLenVec[0], qryLenVec);
}


/**
 * Building index for different software.
 * 
 * 
 * @return void
**/

void VCFMerge::run_index_merge()
{
    vector<string> softwareVec = {ParagraphVcf_, MAPVcf_, GraphTyper2Vcf_, BayesTyperVcf_, GiraffeVcf_, GraphAlignerVcf_, PanGenieVcf_};
    vector<string> softwareNameVec = {"Paragraph", "VG-MAP", "GraphTyper2", "BayesTyper", "VG-Giraffe", "GraphAligner", "PanGenie"};

    for (size_t i = 0; i < softwareVec.size(); i++)
    {
        if (softwareVec[i].length() > 0)
        {
            check_vcf_sort(softwareVec[i]);  // 检查vcf文件是否排序
            
            // 为软件输出特异的索引
            build_softwarefile_index(
                softwareVec[i], 
                softwareNameVec[i]
            );

            softwareNum_++;  // 软件数量加1
        }
    }
}


/**
 * 对软件的结果进行过滤并构建索引，文件为软件的输出文件。
 *
 * @date 2023/07/09
 * 
 * @param vcfFileName        软件输出的vcf文件
 * @param software           软件名
 * 
 * 
 * @return void
**/
void VCFMerge::build_softwarefile_index(
    const string & vcfFileName, 
    const string & software
)
{
    softwareVcfStruct softvcfStructure;  // 输出struct

    softvcfStructure.software = software;  // 软件名

    uint32_t sampleIdx = 0;  // 记录sample在vcf文件的第几列

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Building index: " << software << endl;  // print log

    // input file stream
    VCFINFOSTRUCT INFOSTRUCTTMP;
    VCFOPEN VCFOPENCLASS(vcfFileName);

    while(VCFOPENCLASS.read(INFOSTRUCTTMP)) {
        // 注释行
        if (INFOSTRUCTTMP.line.find("#") != string::npos) {
            // 如果是的话找sample_name索引
            if (INFOSTRUCTTMP.line.find("#CHROM") != string::npos) {
                // 获取sample对应的列数
                if (software == "Paragraph") {  // 因为paragraph会保留原始的列，所以从原始列之后找sample  mergeVcfStruct_.colNum
                    sampleIdx = distance(INFOSTRUCTTMP.lineVec.begin(), find(INFOSTRUCTTMP.lineVec.begin()+mergeVcfStruct_.colNum, INFOSTRUCTTMP.lineVec.end(), sampleName_));  // 获取sample的索引位置
                } else {  // 其它软件都从第10列后找 FORMAT在第9列 
                    sampleIdx = distance(INFOSTRUCTTMP.lineVec.begin(), find(INFOSTRUCTTMP.lineVec.begin()+9, INFOSTRUCTTMP.lineVec.end(), sampleName_));  // 获取sample的索引位置
                }
                
                // 如果没找到，报错并退出代码
                if (sampleIdx == INFOSTRUCTTMP.lineVec.size()) {
                    cerr << "[" << __func__ << "::" << getTime() << "] " 
                        << "Error: '" << sampleName_ << "' is not in the output file of '" 
                        << software << "' -> " << INFOSTRUCTTMP.line 
                        << endl;
                    exit(1);
                }

                mergeVcfStruct_.softwateSampleIdx[software] = sampleIdx; // 软件对应的sample索引添加
            }
        } else {  // 非注释行
            // 判断sample_name找到没有
            if (sampleIdx == 0) {
                cerr << "[" << __func__ << "::" << getTime() << "] " 
                    << "Error: '" << sampleName_ << "' is not in the output file of '" << software << "'"
                    << endl;
                exit(1);
            }
            
            // 获取位点的覆盖度信息
            vector<float> depthVec = get_depth(
                INFOSTRUCTTMP.lineVec, 
                sampleIdx
            );
            float depSum = accumulate(depthVec.begin(), depthVec.end(), 0);  // 计算所有等位基因的深度和
            softvcfStructure.depthVec.push_back(depSum);  // 软件对应的vcf深度列表添加
            
            vector<int> gtVec = get_gt(
                INFOSTRUCTTMP.lineVec, 
                sampleIdx
            );
            string gt = join(gtVec, "/");

            // 根据基因型进行过滤
            if (gt == "0/0" || gt == "0" || gt == "." || gt == "./." || gtVec.size() == 0) {  //如果是(0/0, .)格式的则直接跳过，或者返回了空列表，不构建索引
                cerr << "[" << __func__ << "::" << getTime() << "] "
                    << "Warning: The genotype of the variant is empty, skip this site -> "
                    << INFOSTRUCTTMP.CHROM << "\t" 
                    << INFOSTRUCTTMP.POS << endl;
                continue;
            }

            // 根据FILTER字段进行过滤
            if (INFOSTRUCTTMP.FILTER != "PASS") {  //如果不是(PASS)则直接跳过，不构建索引
                continue;
            }

            // 获取单倍型的长度信息
            int refLen;
            vector<uint32_t> qryLenVec;
            tie(refLen, qryLenVec) = this->get_hap_len(
                INFOSTRUCTTMP.ID, 
                INFOSTRUCTTMP.REF, 
                INFOSTRUCTTMP.ALT, 
                gtVec, 
                "hap"
            );

            // 保存变异的起始和分型信息
            softvcfStructure.startMap[INFOSTRUCTTMP.CHROM].push_back(INFOSTRUCTTMP.POS);
            softvcfStructure.gtVecMap[INFOSTRUCTTMP.CHROM].push_back(gtVec);
            softvcfStructure.depthVecMap[INFOSTRUCTTMP.CHROM].push_back(depthVec);  // 软件对应的vcf深度（每个等位基因的）

            // 保存变异的refLen和qryLenVec
            softvcfStructure.refLenMap[INFOSTRUCTTMP.CHROM].push_back(refLen);
            softvcfStructure.qryLenVecMap[INFOSTRUCTTMP.CHROM].push_back(qryLenVec);
        }
    }

    // 计算软件的平均覆盖度，方差和标准差
    float aveDepth;
    float variance;
    float sd;
    tie(aveDepth, variance, sd) = cal_var_sd(softvcfStructure.depthVec);
    get<0>(mergeVcfStruct_.depthMap[software]) = aveDepth;
    get<1>(mergeVcfStruct_.depthMap[software]) = variance;
    get<2>(mergeVcfStruct_.depthMap[software]) = sd;

    // 将软件的结果加到图中
    vcf_merge(softvcfStructure);
}


// paragraph DP -> 1
// graphaligner, vg-map- vg-giraffe DP -> 6
// bayestyper MAC -> -1,1.87332
// graphtyper DP -> 6
// pangenie KC -> 4
/**
 * 获取位点DP.
 *
 * @param informationsVec     vcfInfoVec
 * @param sampleIdx           sample对应的列
 * 
 * 
 * @return depthVec        vector<depth>
**/
vector<float> VCFMerge::get_depth(
    const vector<string> & informationsVec, 
    const uint32_t & sampleIdx
) {
    vector<float> depthVec;  // 位点覆盖度的vector

    // FORMAT字段拆分
    vector<string> formatVec = split(informationsVec[8], ":");

    uint32_t depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "DP"));  // 获取depth的索引位置

    // BayesTyper软件没有DP字段，所以用MAC字段来代替
    if (depthIndex == formatVec.size()) {
        depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "MAC"));
    }
    // PanGenie软件没有DP字段，所以用KC字段来代替
    if (depthIndex == formatVec.size()) {
        depthIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "KC"));
    }
    
    // 判断index是不是存在，不存在的话返回深度都为0。
    if (depthIndex == formatVec.size()) {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [DP,MAC,KC] information in FORMAT -> " << informationsVec[0] << ":" << informationsVec[1] << endl;
        depthVec = {0, 0};
    }
    // 如果存在，则进行保存
    else {
        vector<string> splitResult = split(informationsVec[sampleIdx], ":");

        // Check if the array is out of bounds
        if (depthIndex < splitResult.size()) {
            auto depthSplit = split(splitResult[depthIndex], ",");
            for (auto it : depthSplit) {
                // BayesTyper's -1 means not found, so change -1 to 0
                if (it == "-1") {
                    it = "0";
                }
                // Prevent error in stof(it) conversion
                try {
                    depthVec.push_back(stof(it));
                } catch (const std::exception& e) {
                    cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: stof(it) conversion failed. Replaced with {0,0} -> " << it << endl;
                    depthVec = {0, 0};
                }
            }
        }
        else {
            cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [DP,MAC,KC] information in column " << sampleIdx << " -> " << informationsVec[sampleIdx] << endl;
            depthVec = {0, 0};
        }
    }

    return depthVec;
}


/**
 * 获取位点基因型列表.
 *
 * @param informationsVec  vcfInfoList
 * @param sampleIdx        sample基因型的索引,默认值0代表最后一列
 * 
 * 
 * @return gtVec           vector <int>
**/
vector<int> VCFMerge::get_gt(
    const vector<string> & informationsVec, 
    uint32_t sampleIdx
) {
    vector<int> gtVec;  // 位点分型的vector

    // FORMAT字符拆分
    vector<string> formatVec = split(informationsVec[8], ":");

    uint32_t gtIndex = distance(formatVec.begin(), find(formatVec.begin(), formatVec.end(), "GT"));  // 获取GT的索引位置

    // // 判断index是否存在，不存在的话返回基因型都为0。
    if (gtIndex == formatVec.size()) {
        cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: no [GT] information in FORMAT -> " << informationsVec[0] << ":" << informationsVec[1] << endl;
        gtVec = {0, 0};
    }
    // 如果存在，则进行保存
    else {
        string gt;  // 存储基因型字段

        // 没有指定列数就是最后一列
        if (sampleIdx == 0) {
            gt = split(informationsVec.back(), ":")[gtIndex];  // gt字段
        }
        else {
            gt = split(informationsVec[sampleIdx], ":")[gtIndex];  // gt字段
        }
        
        string splitStr;  // gt中的分隔符
        // 判断‘/’分隔符
        if (gt.find("/") != string::npos) {
            splitStr = "/";
        }
        // 判断‘|’为分隔符
        else if (gt.find("|") != string::npos) {
            splitStr = "|";
        }
        // 不知道的时候为返回空值
        else {
            gtVec = {0, 0};
            return gtVec;
        }
        
        // 找到gt后，对其按splitStr拆分并循环
        auto splitResult = split(gt, splitStr);
        for (auto it : splitResult) {
            // 如果为'.'，跳过该位点
            if (it == ".") {
                gtVec = {0, 0};
                return gtVec;
            }
            // Prevent error in stof(it) conversion
            try {
                gtVec.push_back(stoi(it));  // 添加到vector中
            } catch (const std::exception& e) {
                cerr << "[" << __func__ << "::" << getTime() << "] " << "Warning: stof(it) conversion failed. Replaced with {0,0} -> " << it << endl;
                gtVec = {0, 0};
                return gtVec;
            }
        }
    }

    return gtVec;
}



/**
 * vcf_merge中recall后添加到总图中函数
 *
 * @date 2023/07/09
 * 
 * @param chromosome         染色体号
 * @param trueRefStart       真实的ref起始位置
 * @param software           软件
 * @param qryLenVec          软件分型的单倍型对应长度
 * @param gtVec              软件的分型gt列表
 * @param gt                 当前循环的gt
 * @param depth              位点对应的深度
 * @param j                  软件多个单倍型循环的索引
 * @param k                  二分查找法两个坐标循环的索引
 * @param l                  真实位点单倍型的循环索引
 * @param indexLeft          二分查找法的左索引
 * @param indexRight         二分查找法的右索引
 * 
 * 
 * @return tuple<int, int>   tuple<state, j>  0 -> 正确添加；-1 -> 需要进行下一个循环
**/
tuple<int, int> VCFMerge::recall_push(
    const string chromosome, 
    const uint32_t trueRefStart, 
    const string software, 
    const vector<uint32_t> qryLenVec, 
    const vector<int> gtVec, 
    const int gt, 
    const float depth, 
    uint32_t j, 
    uint32_t k,
    uint32_t l,
    int64_t & indexLeft, 
    int64_t & indexRight
)
{
    // 先初始化recall哈希表
    if (mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome].find(trueRefStart) == mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome].end()) {  // 如果起始位置第一次见，则初始化
        mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart];
    }
    if (mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart].find(software) == mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart].end()) {  // 如果软件第一次见，则初始化
        vector<float> depthVecTmp(qryLenVec.size());
        vector<int> gtVecTmp(qryLenVec.size());
        mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software] = make_tuple(depthVecTmp, gtVecTmp);
    }

    // gt和l中有一个时0，但另一个不是，则下一个循环，防止SNP判断时候出错
    if ((gt != 0 && l == 0) || (gt == 0 && l != 0)) {
        return make_tuple(-1, j);
    } else {
        // 每个单倍型单独添加
        get<0>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = depth;  // 对应单倍型位置深度
        get<1>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = l;  // 对应单倍型位置基因型

        // 更改二分查找的坐标，下一个等位基因就直接添加到该refStart上
        indexLeft = k; 
        indexRight = k;

        if (j == 0 && gt == gtVec[1]) {  // 如果两个单倍型是一样的，直接赋值，然后跳过下一个循环
            j++;
            get<0>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = depth;  // 对应单倍型位置深度
            get<1>(mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome][trueRefStart][software])[j] = l;  // 对应单倍型位置基因型
        }
    }

    return make_tuple(0, j);
}


/**
 * 对软件的结果进行过滤并构建索引，文件为软件的输出文件。
 *
 * @date 2023/07/09
 * 
 * @param softvcfStructure   build_softwarefile_index构建的软件vcf索引
 * 
 * @return void
**/
void VCFMerge::vcf_merge(
    softwareVcfStruct & softvcfStructure
) {
    vector<string> chromosomeVec;
    string software = softvcfStructure.software;

    cerr << "[" << __func__ << "::" << getTime() << "] " << "Merging: " << software << ".\n";  // print log

    for (auto iter = mergeVcfStruct_.startMap.begin(); iter != mergeVcfStruct_.startMap.end(); iter++) {
        chromosomeVec.push_back(iter->first);
    }

    // for (auto iter = softvcfStructure.startMap.begin(); iter != softvcfStructure.startMap.end(); iter++) {  // 循环软件的vcf（染色体）
    for (const auto& [chromosome, startVec] : softvcfStructure.startMap) {  // 循环软件的vcf（染色体）
        const vector<uint32_t>& refLenVec = softvcfStructure.refLenMap[chromosome];
        const vector<vector<uint32_t> >& qryLenVecVec = softvcfStructure.qryLenVecMap[chromosome];
        const vector<vector<int> >& gtVecVec = softvcfStructure.gtVecMap[chromosome];
        const vector<vector<float> >& depthVecVec = softvcfStructure.depthVecMap[chromosome];

        // 先初始化recall哈希表
        if (mergeVcfStruct_.recallSoftwareGtDepVecMap.find(chromosome) == mergeVcfStruct_.recallSoftwareGtDepVecMap.end()) {  // 如果染色体第一次见，则初始化
            mergeVcfStruct_.recallSoftwareGtDepVecMap[chromosome];
        }

        if (find(chromosomeVec.begin(), chromosomeVec.end(), chromosome) == chromosomeVec.end()) {  // 先看mergeVcfStructure中有没有该染色体，没有的话报错并退出代码
            cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: chromosome is not present in '"<< trueVcf_ << "' -> " << chromosome << endl;
            exit(1);
        } else {  // 如果存在的话，则用二分查找法找最近的变异，判断它们是不是同一个，是的话push，不是的话添加一个新的
            const vector<uint32_t>& mergeRefStartVec = mergeVcfStruct_.startMap[chromosome];
            const vector<uint32_t>& mergeRefLenVec = mergeVcfStruct_.refLenMap[chromosome];
            const vector<vector<uint32_t> >& mergeQryLenVecVec = mergeVcfStruct_.qryLenVecMap[chromosome];  // vector<vector<qryLen>>

            for (size_t i = 0; i < startVec.size(); i++) {  // 循环软件的vcf（位置）
                uint32_t refStart = startVec[i];
                uint32_t refLen = refLenVec[i];
                vector<uint32_t> qryLenVec = qryLenVecVec[i];  // 位点分型对应的等位基因序列长度
                vector<int> gtVec = gtVecVec[i];  // 位点分型对应的分型
                vector<float> depthVec = depthVecVec[i];  // 位点分型对应的等位基因深度

                // 记录二分查找法的索引，多个等位基因用同一个refStart
                int64_t indexLeft = -1;
                int64_t indexRight = -1;

                // 对多个等位基因遍历
                for (size_t j = 0; j < qryLenVec.size(); j++) {
                    uint32_t qryLen = qryLenVec[j];
                    int gt = gtVec[j];
                    float depth = depthVec[j];

                    // 二分查找法找200/10bp内的变异索引。
                    if (indexLeft == -1 && indexRight == -1) {  // 新的等位基因再查找
                        if (refLen <= 49 && qryLen <= 49) {
                            indexLeft = search_Binary_left(mergeRefStartVec, (refStart-10));
                            indexRight = search_Binary_right(mergeRefStartVec, (refStart+10));
                        } else {
                            indexLeft = search_Binary_left(mergeRefStartVec, (refStart-200));
                            indexRight = search_Binary_right(mergeRefStartVec, (refStart+200));
                        }

                        if (indexLeft < 0 || indexRight >= mergeRefStartVec.size()) {
                            cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: out of index, please check the data or code.\n";
                            exit(1);
                        }
                    }

                    for (int64_t k = indexLeft; k <= indexRight; k++) {
                        // true变异的信息
                        vector<uint32_t> mergeQryLenVec = mergeQryLenVecVec[k];  // 多个等位基因的长度
                        uint32_t trueRefLen = mergeRefLenVec[k];
                        uint32_t trueRefStart = mergeRefStartVec[k];

                        // 构造ref和qry共同的长度索引
                        vector<uint32_t> trueSeqLenVec;
                        trueSeqLenVec.push_back(trueRefLen);  // 先添加reference genome的长度
                        trueSeqLenVec.insert(trueSeqLenVec.end(), mergeQryLenVec.begin(), mergeQryLenVec.end());  // 再添加

                        // 如果长度为0，则报错，并退出代码。
                        if (mergeQryLenVec.size() == 0) {
                            cerr << "[" << __func__ << "::" << getTime() << "] " 
                                << "Error: mergeQryLenVec.size() == 0 -> " << chromosome 
                                << " " << mergeRefStartVec[k] << endl;
                            exit(1);
                        }

                        for (size_t l = 0; l < trueSeqLenVec.size(); l++) {  // 一个位点有多个等位基因的时候，trueSeqLenVec存储了各个等位基因的长度，因此遍历它看该位点的变异是否和merge里边的一致，包含0
                            uint32_t trueQryLen = trueSeqLenVec[l];

                            // 缺失
                            if (refLen >= 50 && qryLen < 50) {
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart)) <= 200) &&
                                    (abs((static_cast<int32_t>(refStart + refLen) - static_cast<int32_t>(trueRefStart + trueRefLen)) <= 200)) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen)) / (float)trueRefLen) <= 0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen < 50 && qryLen >= 50) {  // 插入
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=200) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=200) &&
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }

                                    goto stop;
                                }
                            }
                            else if (refLen >= 50 && qryLen >= 50) {  // 替换
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=200) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=200) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen == 1 && qryLen == 1) {  // snp
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=1) &&
                                    (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=1) &&
                                    ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                    ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen >= 3 && qryLen <= 2) {  // del
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=10) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=10) &&
                                ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else if (refLen <= 2 && qryLen >= 3) {  // ins
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=10) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=10) &&
                                ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            } else {
                                if ((abs(static_cast<int32_t>(refStart) - static_cast<int32_t>(trueRefStart))<=1) &&
                                (abs(static_cast<int32_t>(refStart+refLen)-static_cast<int32_t>(trueRefStart+trueRefLen))<=1) &&
                                ((abs(static_cast<int32_t>(refLen) - static_cast<int32_t>(trueRefLen))/(float)trueRefLen)<=0.25) && 
                                ((abs(static_cast<int32_t>(qryLen) - static_cast<int32_t>(trueQryLen))/(float)trueQryLen)<=0.25))
                                {
                                    // 添加到总图中
                                    int recall_state;
                                    tie(recall_state, j) = recall_push(
                                        chromosome, 
                                        trueRefStart, 
                                        software, 
                                        qryLenVec, 
                                        gtVec, 
                                        gt, 
                                        depth, 
                                        j, 
                                        k,
                                        l,
                                        indexLeft, 
                                        indexRight
                                    );

                                    // 没有添加则下一个循环
                                    if (recall_state == -1)
                                    {
                                        continue;
                                    }
                                    
                                    goto stop;
                                }
                            }
                        }
                    }
                    stop:; // 如果找到了，则退出嵌套循环。结束该单倍型的循环，继续下一个单倍型
                }
            }
        }
    }
}


/**
 * 获取变异的长度信息
 *
 * @param vcfInfo           vcfInfo
 * @param gtVec             基因型列表
 * 
 * 
 * @return int              svLength
**/
int64_t VCFMerge::sv_length_select(
    const string & vcfInfo, 
    const vector<int> & gtVec
) {
    int64_t svLength = 0;

    vector<string> vcfInfoVec = split(vcfInfo, "\t");

    // 获取ref和单倍型的长度
    uint32_t refLen;
    vector<uint32_t> qryLenVec;
    tie(refLen, qryLenVec) = this->get_hap_len(
        vcfInfoVec[2], 
        vcfInfoVec[3], 
        vcfInfoVec[4], 
        gtVec, 
        "hap"
    );

    for (size_t i = 0; i < gtVec.size(); i++) {
        if (gtVec[i] == 0) {  // 如果基因型是0，跳过
            continue;
        }
        else {
            svLength = static_cast<int64_t>(qryLenVec[i] - refLen);
        }
    }
    
    return svLength;
}



/**
 * Filter result according to the depth and number of variants.
 *
 * @param gtAllVec        位点所有的gt的vector
 * @param softwareVec     位点所有的software的vector
 * @param depthNorVec     位点所有标准化后的depth的vector
 * @param vcfInfo         位点的变异信息
 * 
 * @return software
**/
string VCFMerge::filter_rule(
    vector<vector<int> > & gtAllVec, 
    vector<string> & softwareVec, 
    vector<float> & depthNorVec, 
    const string & vcfInfo
) {
    // 结果过滤
    vector<string> bestSoftwareVec{};  // 出现频率最高的软件vector
    string selectSoftware;  // 根据sv的长度进行筛选后的软件vector
    int64_t svLength{};
    int gtFrequency = 0;

    // 标准化后的深度最接近0的索引
    float selectDepth = 10000.0;
    int selectDepthIdx = -1;
    for (size_t i = 0; i < depthNorVec.size(); i++) {
        if (abs(depthNorVec[i]) < selectDepth) {
            selectDepth = abs(depthNorVec[i]);  // 更新深度
            selectDepthIdx = i;  // 更新索引
        }
    }

    // 计算每一种基因型出现的频率
    // 先找频率最大的gt
    for (size_t i = 0; i < gtAllVec.size(); i++) {
        svLength = sv_length_select(
            vcfInfo, 
            gtAllVec[i]
        );

        if (count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]) > gtFrequency) {
            gtFrequency = count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]);
        }
    }

    // 把频率最大的gt对应软件找出来
    for (size_t i = 0; i < gtAllVec.size(); i++) {
        if (count(gtAllVec.begin(), gtAllVec.end(), gtAllVec[i]) == gtFrequency) {
            bestSoftwareVec.push_back(softwareVec[i]);
        }
    }

    // 过滤规则
    if (-49 <= svLength && svLength <= 49) {  // snp+indel
        if (mode_ == "specific") {  // 为株系特异的vcf文件
            if (gtFrequency < 2) {  // 支持的软件数量小于2，选取深度最接近于0的基因型
                selectSoftware = softwareVec[selectDepthIdx];  // 选取覆盖度接近于0的软件
            } else {  // 结果有两个以上软件支持的话，则选择该基因型。
                selectSoftware = bestSoftwareVec[0]; // 选择出现频率最高的分型结果
            }
        } else {  // 为构图用的vcf
        
            if (gtFrequency < 2) {  // 结果必须有两个以上的软件支持，否则跳过该位点
                selectSoftware.clear();
            } else {  // 结果有两个以上软件支持的话，则选择该基因型。
                selectSoftware = bestSoftwareVec[0]; // 选择出现频率最高的分型结果
            }
        }
    } else {  // Insertion and Deletion
        vector<string> softwareSortVec = {"BayesTyper", "Paragraph", "VG-MAP", "VG-Giraffe", "GraphTyper2", "GraphAligner", "PanGenie"};
        for (auto it : softwareSortVec) {
            // 大于50bp的变异中如果有it支持，则直接选择it的结果
            if (find(softwareVec.begin(), softwareVec.end(), it) != softwareVec.end()) {
                selectSoftware = it;
                break;
            } else {  // 否则选取覆盖度接近0的软件
                selectSoftware = softwareVec[selectDepthIdx];  // 选取覆盖度接近于0的软件
            }
        }
    }

    return selectSoftware;
}



/*
    vcf过滤
    mergeVcfStruct_ -> 软件合并后的struct
*/

/**
 * Filter and merge result according to the depth and number of variants.
 *
 * @param mode_               EVG运行的模式
 * 
 * @return void
**/
void VCFMerge::vcf_merge_filter()
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Filtering.\n";

    // 遍历recall哈希表
    for (const auto& [chromosome, startSoftwareInfoMap] : mergeVcfStruct_.recallSoftwareGtDepVecMap) {  // map<chr, map<start, map<software, tuple<vector<depth>, vector<gt> > > > >
        for (const auto& [refStart, SoftwareInfoMap] : startSoftwareInfoMap) {  // map<start, map<software, tuple<vector<depth>, vector<gt> > > >
            // 该位点的vcfInfo
            string informations = mergeVcfStruct_.BaseInfoMap[chromosome][refStart];

            // 构造filter_rule的参数
            vector<vector<int>> gtAllVec;
            vector<string> softwareVec;
            vector<float> depthSumVec;
            vector<float> depthNorVec;
            vector<vector<float> > depthVecVec;

            for (const auto& [software, Info] : SoftwareInfoMap) {  // map<software, tuple<vector<depth>, vector<gt> > >
                depthVecVec.push_back(get<0>(Info));

                // 获取软件平均的覆盖度，先检查map中有没有，如果没有则报错
                float meanDepth;
                float sd;
                if (mergeVcfStruct_.depthMap.find(software) != mergeVcfStruct_.depthMap.end()) {
                    meanDepth = get<0>(mergeVcfStruct_.depthMap[software]);
                    sd = get<2>(mergeVcfStruct_.depthMap[software]);
                } else {
                    cerr << "[" << __func__ << "::" << getTime() << "] " << "Error: no coverage information -> "<< software << endl;
                    exit(1);
                }
                float depthSumTmp = accumulate(get<0>(Info).begin(), get<0>(Info).end(), 0);  // 计算所有等位基因的深度和
                depthSumVec.push_back(depthSumTmp);
                
                // 对覆盖度标准化（z-score标准化）
                float depthNor = (depthSumTmp - meanDepth) / (float)sd;
                
                gtAllVec.push_back(get<1>(Info));
                softwareVec.push_back(software);
                depthNorVec.push_back(depthNor);
            }

            // 过滤，选择最有可能的单倍型
            string selectSoftware = filter_rule(
                gtAllVec, 
                softwareVec, 
                depthNorVec, 
                informations
            );

            if (selectSoftware.empty()) {  // 如果返回的是空的字符串，则表明位点不可信，跳过该位点
                continue;
            }

            // 选择的软件索引、基因型和深度信息
            int softwareIdx = distance(softwareVec.begin(), find(softwareVec.begin(), softwareVec.end(), selectSoftware));  // 获取software的索引位置
            vector<int> selectGtVec = gtAllVec[softwareIdx];
            float selectDepthSumVec = depthSumVec[softwareIdx];
            float selectDepthNor = depthNorVec[softwareIdx];
            vector<float> selectDepthVec = depthVecVec[softwareIdx];

            // // save result
            string selectGt = join(selectGtVec, "/");
            selectGt += ":" + selectSoftware 
                    + ":" + to_string(selectDepthNor).substr(0, 5) 
                    + ":" + to_string(get<0>(mergeVcfStruct_.depthMap[selectSoftware])).substr(0, 5) 
                    + ":" + to_string(selectDepthSumVec).substr(0, 5);
            outChrStartInfoMap_[chromosome][refStart] = informations + "\t" + selectGt;
        }
    }
}



/**
 * 计算方差和标准差
 *
 * @param data     含有位点深度的列表
 * 
 * @return tuple   make_tuple(mean, variance, std_deviation)
**/
tuple<float, float, float> VCFMerge::cal_var_sd(const vector<float>& data)
{
    float sum = std::accumulate(std::begin(data), std::end(data), 0.0);
    float mean = sum / data.size();

    float variance = 0.0;
    std::for_each(std::begin(data), std::end(data), [&](const float d) {
        variance += pow(d-mean, 2);
    });
    variance /= data.size();

    float std_deviation = sqrt(variance);

    return make_tuple(mean, variance, std_deviation);
}


/*
    save result
    mergeVcfStruct_ -> 软件合并后的struct
    outChrStartInfoMap_ -> vcf_merge_filter输出结果   outChrStartInfoMap_[chromosome][refStart][refLen][qryLen]
    prefix -> 输出文件名前缀
*/

/**
 * save result
 *
 * 
 * @return void
**/
void VCFMerge::result_save(
)
{
    cerr << "[" << __func__ << "::" << getTime() << "] " << "Wrote genotyped variants to '" << outputFileName_ << "'\n";

    SAVE SaveClass(outputFileName_);

    // 保存需要输出的string
    string outTxt = mergeVcfStruct_.headInfo;
 
    for (const auto& [_, StartInfoMap] : outChrStartInfoMap_) {  // outChrStartInfoMap_<chromosome, map<refStart, vcfInfo> >
        for (const auto& [_, info] : StartInfoMap) {  // map<refStart, vcfInfo>
            outTxt += info + "\n";
        }
    }

    SaveClass.save(outTxt);
}